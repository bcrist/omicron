#include "mesh.hpp"
#include "mesh_manager.hpp"

namespace o {

//////////////////////////////////////////////////////////////////////////////
Mesh::Mesh() noexcept
   : mgr_(nullptr),
     data_(nullptr) { }

//////////////////////////////////////////////////////////////////////////////
Mesh::Mesh(Mesh&& other) noexcept
   : mgr_(other.mgr_),
     data_(other.data_) {
   other.mgr_ = nullptr;
   other.data_ = nullptr;
}

//////////////////////////////////////////////////////////////////////////////
Mesh& Mesh::operator=(Mesh&& other) noexcept {
   reset_();
   mgr_ = other.mgr_;
   data_ = other.data_;
   other.mgr_ = nullptr;
   other.data_ = nullptr;
   return *this;
}

//////////////////////////////////////////////////////////////////////////////
Mesh::~Mesh() {
   reset_();
}

//////////////////////////////////////////////////////////////////////////////
U32 Mesh::size() const {
   return data_->size;
}

//////////////////////////////////////////////////////////////////////////////
void Mesh::size(U32 size) {
   assert(data_->verts.size() >= size);
   data_->size = size;
}

//////////////////////////////////////////////////////////////////////////////
bool Mesh::enabled() const {
   return data_->enabled;
}

//////////////////////////////////////////////////////////////////////////////
void Mesh::enabled(bool enable) {
   data_->enabled = enable;
}

//////////////////////////////////////////////////////////////////////////////
I16 Mesh::layer() const {
   return data_->layer;
}

//////////////////////////////////////////////////////////////////////////////
void Mesh::layer(I16 l) {
   data_->layer = l;
   mgr_->make_dirty_();
}

//////////////////////////////////////////////////////////////////////////////
bool Mesh::depth_test() const {
   return data_->depth_test;
}

//////////////////////////////////////////////////////////////////////////////
void Mesh::depth_test(bool test) {
   data_->depth_test = test;
}

//////////////////////////////////////////////////////////////////////////////
bool Mesh::depth_write() const {
   return data_->depth_write;
}

//////////////////////////////////////////////////////////////////////////////
void Mesh::depth_write(bool write) {
   data_->depth_write = write;
}

//////////////////////////////////////////////////////////////////////////////
GLenum Mesh::blend_func_src() const {
   return data_->blend_src;
}

//////////////////////////////////////////////////////////////////////////////
GLenum Mesh::blend_func_dest() const {
   return data_->blend_dest;
}

//////////////////////////////////////////////////////////////////////////////
void Mesh::blend_func_src(GLenum f) {
   data_->blend_src = f;
   mgr_->make_dirty_();
}

//////////////////////////////////////////////////////////////////////////////
void Mesh::blend_func_dest(GLenum f) {
   data_->blend_dest = f;
   mgr_->make_dirty_();
}

//////////////////////////////////////////////////////////////////////////////
void Mesh::blend_func(GLenum src, GLenum dest) {
   data_->blend_src = src;
   data_->blend_dest = dest;
   mgr_->make_dirty_();
}

//////////////////////////////////////////////////////////////////////////////
GLuint Mesh::texture_glid() const {
   return data_->tex_id;
}

//////////////////////////////////////////////////////////////////////////////
void Mesh::texture_glid(GLuint id) {
   data_->tex_id = id;
   mgr_->make_dirty_();
}

//////////////////////////////////////////////////////////////////////////////
mat4* Mesh::transform() const {
   return data_->transform;
}

//////////////////////////////////////////////////////////////////////////////
void Mesh::transform(mat4* ptr) {
   data_->transform = ptr;
   mgr_->make_dirty_();
}

//////////////////////////////////////////////////////////////////////////////
Buf<Vertex> Mesh::verts() {
   // TODO if switching to use VBO, we probably need to mark it dirty here
   return tmp_buf(data_->verts);
}

//////////////////////////////////////////////////////////////////////////////
Buf<const Vertex> Mesh::verts() const {
   return tmp_buf(data_->verts);
}

//////////////////////////////////////////////////////////////////////////////
void Mesh::assign_(MeshManager* mgr, MeshData* data) {
   reset_();
   mgr_ = mgr;
   data_ = data;
}

//////////////////////////////////////////////////////////////////////////////
void Mesh::reset_() {
   if (mgr_ != nullptr) {
      mgr_->reclaim_(data_);
      mgr_ = nullptr;
      data_ = nullptr;
   }
}

} // o
